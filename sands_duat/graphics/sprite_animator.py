"""
Advanced Sprite Animator for Sands of Duat
Integrates with the professional asset pipeline to load and animate sprite sheets
"""

import pygame
import json
import os
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass
from enum import Enum

class AnimationState(Enum):
    IDLE = "idle"
    WALK = "walk"
    ATTACK = "attack"
    DEATH = "death"
    CAST = "cast"


@dataclass
class SpriteFrame:
    """Individual frame in a sprite animation"""
    surface: pygame.Surface
    duration: float
    metadata: Dict[str, Any]


@dataclass
class SpriteAnimation:
    """Complete animation with all frames"""
    name: str
    frames: List[SpriteFrame]
    loop: bool
    fps: float
    total_duration: float


class SpriteAnimator:
    """
    Loads and manages sprite sheet animations generated by the asset pipeline
    """
    
    def __init__(self, asset_root: str = "game_assets"):
        self.asset_root = Path(asset_root)
        self.sprite_cache: Dict[str, pygame.Surface] = {}
        self.animation_cache: Dict[str, Dict[str, SpriteAnimation]] = {}
        
        # Animation state
        self.current_animation: Optional[SpriteAnimation] = None
        self.current_frame_index: int = 0
        self.animation_timer: float = 0.0
        self.animation_finished: bool = False
        
    def load_character_animations(self, character_slug: str) -> Dict[str, SpriteAnimation]:
        """Load all animations for a character from individual sprite files"""
        if character_slug in self.animation_cache:
            return self.animation_cache[character_slug]
        
        character_animations = {}
        sprites_dir = self.asset_root / "characters" / "sprites"
        
        # Look for individual sprite files (e.g., "anubis_guardian_idle.png")
        actions = ["idle", "walk", "attack"]
        for action in actions:
            sprite_file = sprites_dir / f"{character_slug}_{action}.png"
            if sprite_file.exists():
                animation = self._load_single_sprite_animation(sprite_file, action)
                if animation:
                    character_animations[action] = animation
        
        self.animation_cache[character_slug] = character_animations
        return character_animations
    
    def _load_single_sprite_animation(self, sprite_path: Path, action: str) -> Optional[SpriteAnimation]:
        """Load a single sprite image as a static animation"""
        try:
            # Load sprite image
            sprite_image = pygame.image.load(str(sprite_path)).convert_alpha()
            
            # Create single frame animation
            frame = SpriteFrame(
                surface=sprite_image,
                duration=1.0,  # Static frame
                metadata={"action": action, "type": "static"}
            )
            
            # Create animation with single frame
            animation = SpriteAnimation(
                name=action,
                frames=[frame],
                loop=action in ["idle", "walk"],
                fps=1.0,  # Static
                total_duration=1.0
            )
            
            return animation
            
        except Exception as e:
            print(f"Failed to load sprite {sprite_path}: {e}")
            return None
    
    def _load_sprite_sheet_animation(self, sprite_path: Path, metadata: Dict[str, Any], 
                                   action: str) -> Optional[SpriteAnimation]:
        """Load a sprite sheet and convert to animation"""
        try:
            # Load sprite sheet
            sprite_sheet = pygame.image.load(str(sprite_path)).convert_alpha()
            
            # Extract frame information from metadata
            frame_count = metadata.get('frames', 6)
            frame_size = metadata.get('frame_size', [64, 64])
            fps = metadata.get('fps', 12.0)
            
            # Extract individual frames
            frames = []
            frame_width, frame_height = frame_size
            frame_duration = 1.0 / fps
            
            for i in range(frame_count):
                # Calculate frame position
                x = i * frame_width
                y = 0
                
                # Extract frame
                frame_rect = pygame.Rect(x, y, frame_width, frame_height)
                frame_surface = pygame.Surface((frame_width, frame_height), pygame.SRCALPHA)
                frame_surface.blit(sprite_sheet, (0, 0), frame_rect)
                
                # Create frame object
                frame = SpriteFrame(
                    surface=frame_surface,
                    duration=frame_duration,
                    metadata={"frame_index": i, "action": action}
                )
                frames.append(frame)
            
            # Create animation
            total_duration = frame_count * frame_duration
            animation = SpriteAnimation(
                name=action,
                frames=frames,
                loop=action in ["idle", "walk"],  # Loop idle and walk animations
                fps=fps,
                total_duration=total_duration
            )
            
            return animation
            
        except Exception as e:
            print(f"Failed to load sprite animation {sprite_path}: {e}")
            return None
    
    def set_animation(self, animation: SpriteAnimation, reset: bool = True) -> None:
        """Set the current animation"""
        if self.current_animation != animation or reset:
            self.current_animation = animation
            self.current_frame_index = 0
            self.animation_timer = 0.0
            self.animation_finished = False
    
    def update(self, delta_time: float) -> bool:
        """Update animation and return True if animation changed"""
        if not self.current_animation or not self.current_animation.frames:
            return False
        
        frame_changed = False
        self.animation_timer += delta_time
        
        # Get current frame
        current_frame = self.current_animation.frames[self.current_frame_index]
        
        # Check if we need to advance to next frame
        if self.animation_timer >= current_frame.duration:
            self.animation_timer -= current_frame.duration
            self.current_frame_index += 1
            frame_changed = True
            
            # Handle animation end
            if self.current_frame_index >= len(self.current_animation.frames):
                if self.current_animation.loop:
                    self.current_frame_index = 0
                else:
                    self.current_frame_index = len(self.current_animation.frames) - 1
                    self.animation_finished = True
        
        return frame_changed
    
    def get_current_frame(self) -> Optional[pygame.Surface]:
        """Get the current frame surface"""
        if not self.current_animation or not self.current_animation.frames:
            return None
        
        return self.current_animation.frames[self.current_frame_index].surface
    
    def is_animation_finished(self) -> bool:
        """Check if current animation is finished (for non-looping animations)"""
        return self.animation_finished
    
    def get_animation_progress(self) -> float:
        """Get animation progress as 0.0 to 1.0"""
        if not self.current_animation:
            return 0.0
        
        frame_progress = self.current_frame_index / len(self.current_animation.frames)
        current_frame = self.current_animation.frames[self.current_frame_index]
        frame_time_progress = self.animation_timer / current_frame.duration
        
        return frame_progress + (frame_time_progress / len(self.current_animation.frames))


class CharacterSprite:
    """
    Enhanced high-level character sprite that manages animations and rendering
    """
    
    def __init__(self, character_slug: str, asset_root: str = "game_assets"):
        self.character_slug = character_slug
        self.animator = SpriteAnimator(asset_root)
        self.animations = self.animator.load_character_animations(character_slug)
        
        # State
        self.current_state = AnimationState.IDLE
        self.position = (0.0, 0.0)  # Use floats for smooth movement
        self.target_position = (0.0, 0.0)
        self.scale = 1.0
        self.target_scale = 1.0
        self.flip_horizontal = False
        self.alpha = 255
        self.target_alpha = 255
        
        # Animation enhancements
        self.movement_speed = 200.0  # pixels per second
        self.scale_speed = 2.0  # scale units per second
        self.alpha_speed = 300.0  # alpha units per second
        self.smooth_transitions = True
        
        # Visual effects
        self.screen_shake_intensity = 0.0
        self.screen_shake_duration = 0.0
        self.screen_shake_time = 0.0
        self.glow_effect = False
        self.glow_color = (255, 255, 255)
        self.glow_intensity = 0.0
        
        # Set default idle animation
        if AnimationState.IDLE.value in self.animations:
            self.animator.set_animation(self.animations[AnimationState.IDLE.value])
    
    def set_state(self, state: AnimationState, force_restart: bool = False) -> None:
        """Set character animation state"""
        if state == self.current_state and not force_restart:
            return
        
        self.current_state = state
        
        if state.value in self.animations:
            self.animator.set_animation(self.animations[state.value], reset=force_restart)
        else:
            # Fallback to idle
            if AnimationState.IDLE.value in self.animations:
                self.animator.set_animation(self.animations[AnimationState.IDLE.value])
    
    def update(self, delta_time: float) -> None:
        """Enhanced update with smooth transitions and effects"""
        frame_changed = self.animator.update(delta_time)
        
        if self.smooth_transitions:
            # Smooth position transitions
            if self.position != self.target_position:
                dx = self.target_position[0] - self.position[0]
                dy = self.target_position[1] - self.position[1]
                distance = (dx*dx + dy*dy) ** 0.5
                
                if distance > 1.0:  # Only move if significant distance
                    move_distance = min(self.movement_speed * delta_time, distance)
                    if distance > 0:
                        move_x = (dx / distance) * move_distance
                        move_y = (dy / distance) * move_distance
                        self.position = (self.position[0] + move_x, self.position[1] + move_y)
                else:
                    self.position = self.target_position
            
            # Smooth scale transitions
            if abs(self.scale - self.target_scale) > 0.01:
                scale_diff = self.target_scale - self.scale
                scale_change = min(abs(scale_diff), self.scale_speed * delta_time)
                if scale_diff > 0:
                    self.scale += scale_change
                else:
                    self.scale -= scale_change
            else:
                self.scale = self.target_scale
            
            # Smooth alpha transitions
            if abs(self.alpha - self.target_alpha) > 1:
                alpha_diff = self.target_alpha - self.alpha
                alpha_change = min(abs(alpha_diff), self.alpha_speed * delta_time)
                if alpha_diff > 0:
                    self.alpha += alpha_change
                else:
                    self.alpha -= alpha_change
            else:
                self.alpha = self.target_alpha
        
        # Update screen shake
        if self.screen_shake_duration > 0:
            self.screen_shake_time += delta_time
            self.screen_shake_duration -= delta_time
            if self.screen_shake_duration <= 0:
                self.screen_shake_intensity = 0.0
        
        # Auto-return to idle after non-looping animations
        if self.animator.is_animation_finished() and self.current_state != AnimationState.IDLE:
            self.set_state(AnimationState.IDLE)
    
    def render(self, surface: pygame.Surface, camera_offset: Tuple[int, int] = (0, 0)) -> None:
        """Enhanced render with effects"""
        frame_surface = self.animator.get_current_frame()
        if not frame_surface:
            return
        
        # Apply transformations
        render_surface = frame_surface
        
        # Scale with smoothscale for better quality when scaling AI sprites
        if self.scale != 1.0:
            new_size = (int(frame_surface.get_width() * self.scale),
                       int(frame_surface.get_height() * self.scale))
            render_surface = pygame.transform.smoothscale(render_surface, new_size)
        
        # Flip
        if self.flip_horizontal:
            render_surface = pygame.transform.flip(render_surface, True, False)
        
        # Alpha
        if self.alpha != 255:
            render_surface = render_surface.copy()
            render_surface.set_alpha(int(self.alpha))
        
        # Calculate render position with screen shake
        shake_x = 0
        shake_y = 0
        if self.screen_shake_intensity > 0:
            import random
            import math
            shake_magnitude = self.screen_shake_intensity * math.sin(self.screen_shake_time * 15)
            shake_x = random.uniform(-shake_magnitude, shake_magnitude)
            shake_y = random.uniform(-shake_magnitude, shake_magnitude)
        
        render_x = int(self.position[0] - camera_offset[0] - render_surface.get_width() // 2 + shake_x)
        render_y = int(self.position[1] - camera_offset[1] - render_surface.get_height() // 2 + shake_y)
        
        # Draw glow effect if enabled
        if self.glow_effect and self.glow_intensity > 0:
            self._render_glow_effect(surface, render_surface, render_x, render_y)
        
        # Draw main sprite
        surface.blit(render_surface, (render_x, render_y))
    
    def _render_glow_effect(self, surface: pygame.Surface, sprite_surface: pygame.Surface, 
                           x: int, y: int) -> None:
        """Render glow effect around sprite"""
        try:
            # Create glow surface
            glow_size = int(self.glow_intensity * 10)
            if glow_size <= 0:
                return
            
            glow_surface = pygame.Surface(
                (sprite_surface.get_width() + glow_size * 2, 
                 sprite_surface.get_height() + glow_size * 2), 
                pygame.SRCALPHA
            )
            
            # Draw multiple glow layers for smooth effect
            for i in range(glow_size, 0, -2):
                alpha = int((self.glow_intensity * 255) * (i / glow_size) * 0.3)
                if alpha > 0:
                    glow_color = (*self.glow_color, alpha)
                    glow_rect = pygame.Rect(
                        glow_size - i, glow_size - i,
                        sprite_surface.get_width() + i * 2,
                        sprite_surface.get_height() + i * 2
                    )
                    pygame.draw.rect(glow_surface, glow_color, glow_rect)
            
            # Blit glow effect
            surface.blit(glow_surface, (x - glow_size, y - glow_size))
            
        except Exception as e:
            # Fail silently if glow effect can't be rendered
            pass
    
    def get_rect(self) -> pygame.Rect:
        """Get bounding rectangle for collision detection"""
        frame_surface = self.animator.get_current_frame()
        if not frame_surface:
            return pygame.Rect(0, 0, 0, 0)
        
        width = int(frame_surface.get_width() * self.scale)
        height = int(frame_surface.get_height() * self.scale)
        
        return pygame.Rect(
            self.position[0] - width // 2,
            self.position[1] - height // 2,
            width, height
        )
    
    def set_position(self, x: int, y: int, smooth: bool = True) -> None:
        """Set character position with optional smooth transition"""
        if smooth and self.smooth_transitions:
            self.target_position = (float(x), float(y))
        else:
            self.position = (float(x), float(y))
            self.target_position = (float(x), float(y))
    
    def set_scale(self, scale: float, smooth: bool = True) -> None:
        """Set character scale with optional smooth transition"""
        if smooth and self.smooth_transitions:
            self.target_scale = scale
        else:
            self.scale = scale
            self.target_scale = scale
    
    def set_alpha(self, alpha: int, smooth: bool = True) -> None:
        """Set character alpha (0-255) with optional smooth transition"""
        alpha = max(0, min(255, alpha))
        if smooth and self.smooth_transitions:
            self.target_alpha = alpha
        else:
            self.alpha = alpha
            self.target_alpha = alpha
    
    def move_to(self, x: int, y: int, speed: float = None) -> None:
        """Move to position with custom speed"""
        if speed:
            old_speed = self.movement_speed
            self.movement_speed = speed
        self.set_position(x, y, smooth=True)
        if speed:
            self.movement_speed = old_speed
    
    def scale_to(self, scale: float, speed: float = None) -> None:
        """Scale to size with custom speed"""
        if speed:
            old_speed = self.scale_speed
            self.scale_speed = speed
        self.set_scale(scale, smooth=True)
        if speed:
            self.scale_speed = old_speed
    
    def fade_to(self, alpha: int, speed: float = None) -> None:
        """Fade to alpha with custom speed"""
        if speed:
            old_speed = self.alpha_speed
            self.alpha_speed = speed
        self.set_alpha(alpha, smooth=True)
        if speed:
            self.alpha_speed = old_speed
    
    def trigger_screen_shake(self, intensity: float, duration: float) -> None:
        """Trigger screen shake effect"""
        self.screen_shake_intensity = intensity
        self.screen_shake_duration = duration
        self.screen_shake_time = 0.0
    
    def set_glow(self, enabled: bool, color: Tuple[int, int, int] = (255, 255, 255), 
                 intensity: float = 1.0) -> None:
        """Set glow effect"""
        self.glow_effect = enabled
        self.glow_color = color
        self.glow_intensity = intensity
    
    def is_moving(self) -> bool:
        """Check if sprite is currently moving"""
        return self.position != self.target_position
    
    def is_scaling(self) -> bool:
        """Check if sprite is currently scaling"""
        return abs(self.scale - self.target_scale) > 0.01
    
    def is_fading(self) -> bool:
        """Check if sprite is currently fading"""
        return abs(self.alpha - self.target_alpha) > 1
    
    def set_flip(self, flip_horizontal: bool) -> None:
        """Set horizontal flip"""
        self.flip_horizontal = flip_horizontal
    
    def has_animation(self, state: AnimationState) -> bool:
        """Check if character has animation for given state"""
        return state.value in self.animations
    
    def get_available_animations(self) -> List[str]:
        """Get list of available animation names"""
        return list(self.animations.keys())


# Egyptian-themed character presets
EGYPTIAN_CHARACTERS = {
    "anubis_guardian": {
        "scale": 2.0,
        "combat_position": (200, 400),
        "description": "Anubis-headed guardian warrior"
    },
    "desert_scorpion": {
        "scale": 1.5,
        "combat_position": (300, 450),
        "description": "Giant desert scorpion"
    },
    "pharaoh_lich": {
        "scale": 2.2,
        "combat_position": (250, 350),
        "description": "Undead pharaoh"
    },
    "temple_guardian": {
        "scale": 2.5,
        "combat_position": (180, 300),
        "description": "Stone temple guardian"
    },
    "player_character": {
        "scale": 2.0,
        "combat_position": (600, 400),
        "description": "Egyptian warrior adventurer"
    }
}


def create_character_sprite(character_slug: str, asset_root: str = "game_assets") -> CharacterSprite:
    """Factory function to create character sprites with Egyptian presets"""
    sprite = CharacterSprite(character_slug, asset_root)
    
    if character_slug in EGYPTIAN_CHARACTERS:
        preset = EGYPTIAN_CHARACTERS[character_slug]
        sprite.set_scale(preset["scale"])
        sprite.set_position(*preset["combat_position"])
    
    return sprite