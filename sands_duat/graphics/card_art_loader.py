"""
Card Art Loader for AI Generated Assets
Loads professional card artwork generated by the AI pipeline
"""

import pygame
from pathlib import Path
from typing import Dict, Optional
import logging


class CardArtLoader:
    """Enhanced loader and manager for AI-generated card artwork"""
    
    def __init__(self, asset_root: str = "game_assets"):
        self.asset_root = Path(asset_root)
        self.cards_dir = self.asset_root / "cards"
        self.card_cache: Dict[str, pygame.Surface] = {}  # Raw cache
        self.scaled_cache: Dict[str, pygame.Surface] = {}  # Size-specific cache
        self.logger = logging.getLogger(__name__)
        
        # Performance tracking
        self.cache_hits = 0
        self.cache_misses = 0
        self.loading_stats = {}
        
        # Quality settings
        self.enable_high_quality_scaling = True
        self.enable_anti_aliasing = True
        self.max_cache_size = 50  # Limit memory usage
        
        # Card name mapping (game name -> file name)
        self.card_mapping = {
            # Starter cards
            "Desert Whisper": "desert_whisper",
            "Sand Grain": "sand_grain", 
            "Tomb Strike": "tomb_strike",
            "Ankh Blessing": "ankh_blessing",
            "Scarab Swarm": "scarab_swarm",
            "Papyrus Scroll": "papyrus_scroll",
            "Mummy's Wrath": "mummys_wrath",
            "Isis's Grace": "isis_grace",
            "Pyramid Power": "pyramid_power",  
            "Thoth's Wisdom": "thoths_wisdom",
            "Anubis Judgment": "anubis_judgment",
            "Ra's Solar Flare": "ra_solar_flare",
            "Pharaoh's Resurrection": "pharaohs_resurrection"
        }
    
    def load_card_art(self, card_name: str, size: tuple = None) -> Optional[pygame.Surface]:
        """Enhanced card art loading with smart caching and quality optimization"""
        # Create cache key for size-specific caching
        cache_key = f"{card_name}_{size}" if size else card_name
        
        # Check scaled cache first for exact size matches
        if size and cache_key in self.scaled_cache:
            self.cache_hits += 1
            return self.scaled_cache[cache_key]
        
        # Check raw cache for base image
        base_surface = None
        if card_name in self.card_cache:
            base_surface = self.card_cache[card_name]
            self.cache_hits += 1
        else:
            self.cache_misses += 1
            base_surface = self._load_raw_card_art(card_name)
            
        if not base_surface:
            return self._create_placeholder_card(card_name, size)
        
        # Handle resizing with quality optimization
        if size and size != base_surface.get_size():
            scaled_surface = self._scale_with_quality(base_surface, size)
            
            # Cache the scaled version (with memory management)
            self._cache_scaled_surface(cache_key, scaled_surface)
            return scaled_surface
        
        return base_surface
    
    def _load_raw_card_art(self, card_name: str) -> Optional[pygame.Surface]:
        """Load raw card art from disk"""
        # Get file name from mapping
        file_name = self.card_mapping.get(card_name)
        if not file_name:
            self.logger.warning(f"No artwork mapping found for card: {card_name}")
            return None
        
        # Load from AI generated assets
        card_path = self.cards_dir / f"{file_name}.png"
        if not card_path.exists():
            self.logger.warning(f"Card artwork not found: {card_path}")
            return None
        
        try:
            # Load high-quality AI artwork
            card_surface = pygame.image.load(str(card_path))
            
            # Convert for optimal performance
            try:
                card_surface = card_surface.convert_alpha()
            except pygame.error:
                # Fallback if no display mode set
                pass
            
            # Cache raw surface
            self._cache_raw_surface(card_name, card_surface)
            
            # Track loading stats
            self.loading_stats[card_name] = {
                'path': str(card_path),
                'original_size': card_surface.get_size(),
                'file_size': card_path.stat().st_size if card_path.exists() else 0
            }
            
            self.logger.info(f"Loaded AI card art: {card_name} ({card_surface.get_size()}) from {card_path}")
            return card_surface
            
        except Exception as e:
            self.logger.error(f"Failed to load card art {card_path}: {e}")
            return None
    
    def _scale_with_quality(self, surface: pygame.Surface, target_size: tuple) -> pygame.Surface:
        """Scale surface with quality optimization"""
        if not self.enable_high_quality_scaling:
            return pygame.transform.scale(surface, target_size)
        
        # Use smooth scaling for better quality
        return pygame.transform.smoothscale(surface, target_size)
    
    def _cache_raw_surface(self, card_name: str, surface: pygame.Surface) -> None:
        """Cache raw surface with memory management"""
        # Manage cache size
        if len(self.card_cache) >= self.max_cache_size:
            # Remove oldest entry (simple LRU)
            oldest_key = next(iter(self.card_cache))
            del self.card_cache[oldest_key]
            self.logger.debug(f"Removed {oldest_key} from raw cache (size limit)")
        
        self.card_cache[card_name] = surface
    
    def _cache_scaled_surface(self, cache_key: str, surface: pygame.Surface) -> None:
        """Cache scaled surface with memory management"""
        # Manage scaled cache size
        if len(self.scaled_cache) >= self.max_cache_size * 2:  # Allow more scaled versions
            # Remove oldest entry
            oldest_key = next(iter(self.scaled_cache))
            del self.scaled_cache[oldest_key]
            self.logger.debug(f"Removed {oldest_key} from scaled cache (size limit)")
        
        self.scaled_cache[cache_key] = surface
    
    def _create_placeholder_card(self, card_name: str, size: tuple = None) -> pygame.Surface:
        """Create placeholder card if AI art not available"""
        if not size:
            size = (200, 300)  # Default card size
        
        # Create simple placeholder
        surface = pygame.Surface(size, pygame.SRCALPHA)
        surface.fill((139, 69, 19))  # Egyptian brown
        
        # Add border
        pygame.draw.rect(surface, (218, 165, 32), surface.get_rect(), 3)
        
        # Add card name text
        font = pygame.font.Font(None, 24)
        text = font.render(card_name, True, (218, 165, 32))
        text_rect = text.get_rect(center=(size[0]//2, size[1]//2))
        surface.blit(text, text_rect)
        
        return surface
    
    def preload_all_cards(self):
        """Preload all available card artwork"""
        self.logger.info("Preloading AI card artwork...")
        loaded_count = 0
        
        for card_name in self.card_mapping.keys():
            if self.load_card_art(card_name):
                loaded_count += 1
        
        self.logger.info(f"Preloaded {loaded_count}/{len(self.card_mapping)} card artworks")
        return loaded_count
    
    def get_available_cards(self) -> list:
        """Get list of cards with AI artwork available"""
        available = []
        for card_name, file_name in self.card_mapping.items():
            card_path = self.cards_dir / f"{file_name}.png"
            if card_path.exists():
                available.append(card_name)
        return available
    
    def get_performance_stats(self) -> dict:
        """Get performance statistics"""
        total_requests = self.cache_hits + self.cache_misses
        hit_rate = (self.cache_hits / total_requests * 100) if total_requests > 0 else 0
        
        return {
            "cache_hits": self.cache_hits,
            "cache_misses": self.cache_misses,
            "hit_rate_percent": hit_rate,
            "raw_cache_size": len(self.card_cache),
            "scaled_cache_size": len(self.scaled_cache),
            "total_cards_loaded": len(self.loading_stats)
        }
    
    def clear_cache(self) -> None:
        """Clear all caches"""
        old_size = len(self.card_cache) + len(self.scaled_cache)
        self.card_cache.clear()
        self.scaled_cache.clear()
        self.logger.info(f"Cleared {old_size} cached card surfaces")
    
    def optimize_cache(self) -> None:
        """Optimize cache by removing least recently used items"""
        # This is a simplified optimization - a full LRU implementation would track access times
        if len(self.card_cache) > self.max_cache_size * 0.8:
            # Remove oldest 20% of items
            items_to_remove = int(len(self.card_cache) * 0.2)
            for _ in range(items_to_remove):
                if self.card_cache:
                    oldest_key = next(iter(self.card_cache))
                    del self.card_cache[oldest_key]
        
        if len(self.scaled_cache) > self.max_cache_size * 1.6:  # 80% of max scaled cache
            items_to_remove = int(len(self.scaled_cache) * 0.2)
            for _ in range(items_to_remove):
                if self.scaled_cache:
                    oldest_key = next(iter(self.scaled_cache))
                    del self.scaled_cache[oldest_key]


# Global card art loader instance
_card_loader = None

def get_card_art_loader() -> CardArtLoader:
    """Get global card art loader instance"""
    global _card_loader
    if _card_loader is None:
        _card_loader = CardArtLoader()
    return _card_loader

def load_card_art(card_name: str, size: tuple = None) -> Optional[pygame.Surface]:
    """Convenience function to load card art"""
    return get_card_art_loader().load_card_art(card_name, size)