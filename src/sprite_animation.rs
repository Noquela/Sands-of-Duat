use bevy::prelude::*;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Component)]
pub struct SpriteAnimation {
    pub atlas_handle: Handle<TextureAtlasLayout>,
    pub current_animation: String,
    pub frame_timer: Timer,
    pub current_frame: usize,
}

#[derive(Component)]
pub struct AnimationSet {
    pub animations: HashMap<String, AnimationSequence>,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct AnimationSequence {
    pub name: String,
    pub frames: Vec<usize>,
    pub frame_duration: f32,
    pub looping: bool,
}

#[derive(Component)]
pub struct Billboard;

pub struct SpriteAnimationPlugin;

impl Plugin for SpriteAnimationPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, (
            animate_sprites,
            billboard_system,
        ));
    }
}

// System to animate sprite atlases
fn animate_sprites(
    time: Res<Time>,
    mut query: Query<(&mut SpriteAnimation, &AnimationSet, &mut TextureAtlas)>,
) {
    for (mut animation, animation_set, mut atlas) in &mut query {
        // Update timer
        animation.frame_timer.tick(time.delta());
        
        if animation.frame_timer.finished() {
            // Get current animation sequence
            if let Some(sequence) = animation_set.animations.get(&animation.current_animation) {
                // Advance to next frame
                animation.current_frame += 1;
                
                if animation.current_frame >= sequence.frames.len() {
                    if sequence.looping {
                        animation.current_frame = 0;
                    } else {
                        animation.current_frame = sequence.frames.len() - 1;
                    }
                }
                
                // Update atlas index
                if let Some(&frame_index) = sequence.frames.get(animation.current_frame) {
                    atlas.index = frame_index;
                }
                
                // Reset timer for next frame
                animation.frame_timer.reset();
            }
        }
    }
}

// System to make sprites face the camera (billboard effect)
fn billboard_system(
    camera_query: Query<&GlobalTransform, (With<Camera3d>, Without<Billboard>)>,
    mut billboard_query: Query<&mut Transform, With<Billboard>>,
) {
    if let Ok(camera_transform) = camera_query.get_single() {
        for mut transform in &mut billboard_query {
            // Calculate direction to camera
            let to_camera = (camera_transform.translation() - transform.translation).normalize();
            
            // Calculate rotation to face camera (only Y-axis rotation for isometric look)
            let forward = Vec3::NEG_Z;
            let right = to_camera.cross(Vec3::Y).normalize();
            let up = Vec3::Y;
            let new_forward = right.cross(up);
            
            // Apply rotation
            transform.rotation = Quat::from_mat3(&Mat3::from_cols(right, up, new_forward));
        }
    }
}

// Helper function to create animation from atlas metadata
pub fn create_animation_from_atlas(
    atlas_meta_path: &str,
    asset_server: &AssetServer,
) -> Result<(Handle<Image>, Handle<TextureAtlasLayout>, AnimationSet), Box<dyn std::error::Error>> {
    // This would typically load from a JSON file generated by make_atlas.py
    // For now, we'll create a simple animation
    
    let texture_handle: Handle<Image> = asset_server.load("sprites/player_idle.png");
    
    // Create atlas layout (would be loaded from JSON in real implementation)
    let layout = TextureAtlasLayout::from_grid(Vec2::new(128.0, 128.0), 4, 2, None, None);
    let layout_handle = Handle::default(); // Would be added to texture_atlas_layouts
    
    // Create animation set
    let mut animations = HashMap::new();
    animations.insert("idle".to_string(), AnimationSequence {
        name: "idle".to_string(),
        frames: vec![0, 1, 2, 3],
        frame_duration: 0.2,
        looping: true,
    });
    
    let animation_set = AnimationSet { animations };
    
    Ok((texture_handle, layout_handle, animation_set))
}

// Helper function to spawn animated sprite
pub fn spawn_animated_sprite(
    commands: &mut Commands,
    meshes: &mut Assets<Mesh>,
    materials: &mut Assets<StandardMaterial>,
    texture_handle: Handle<Image>,
    position: Vec3,
    scale: f32,
) -> Entity {
    commands.spawn((
        PbrBundle {
            mesh: meshes.add(Plane3d::default().mesh().size(scale, scale)),
            material: materials.add(StandardMaterial {
                base_color_texture: Some(texture_handle),
                alpha_mode: AlphaMode::Blend,
                unlit: true,
                double_sided: true,
                ..default()
            }),
            transform: Transform::from_translation(position),
            ..default()
        },
        Billboard,
        // Animation components would be added here
    )).id()
}

// Helper to load animation metadata from JSON (generated by make_atlas.py)
#[derive(Serialize, Deserialize)]
pub struct AtlasMetadata {
    pub w: u32,
    pub h: u32, 
    pub cols: u32,
    pub rows: u32,
    pub frames: Vec<FrameData>,
}

#[derive(Serialize, Deserialize)]
pub struct FrameData {
    pub i: usize,
    pub x: u32,
    pub y: u32,
    pub w: u32,
    pub h: u32,
    pub name: String,
}